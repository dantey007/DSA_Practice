/*Equal
Programming
Hashing
Medium
31.3% Success

204

17

Bookmark
Asked In:
Problem Description
 
 

Given an array A of N integers, find the index of values that satisfy P + Q = R + S, where P, Q, R & S are integers values in the array

Expected time complexity O(N2)

NOTE:
1) Return the indices A1 B1 C1 D1, so that 
  A[A1] + A[B1] = A[C1] + A[D1]
  A1 < B1, C1 < D1
  A1 < C1, B1 != D1, B1 != C1 
2) If there are more than one solutions,
   then return the tuple of values which are lexicographical smallest. 

Assume we have two solutions
S1 : A1 B1 C1 D1 ( these are values of indices in the array )
S2 : A2 B2 C2 D2

S1 is lexicographically smaller than S2 if:
  A1 < A2 OR
  A1 = A2 AND B1 < B2 OR
  A1 = A2 AND B1 = B2 AND C1 < C2 OR 
  A1 = A2 AND B1 = B2 AND C1 = C2 AND D1 < D2
If no solution is possible, return an empty list.


Problem Constraints
1 <= N <= 1000

0 <= A[i] <= 1000



Input Format
First and only argument is an integer array A of length N.



Output Format
Return an array of size four which contains indices of values P, Q, R, and S.



Example Input
Input 1:

 A = [3, 4, 7, 1, 2, 9, 8]
Input 2:

 A = [2, 5, 1, 6]


Example Output
Output 1:

 [0, 2, 3, 5]
Output 2:

 [0, 1, 2, 3]*/
function solve(arr) {
        let map = {};
        let ans = [];
        
        for (let i = 0; i < arr.length; i++) {
            for (let j = i + 1; j < arr.length; j++) {
                let sum = arr[i] + arr[j];
                
                if (map.hasOwnProperty(sum)) {
                  let values = map[sum];
                  let a1 = values[values.length-1][0];
                  let c1 = i;
                  let b1 = values[values.length-1][1];
                  let d1 = j;
                  
                  // A1 < C1, B1 != D1, B1 != C1 
                  if (a1 < c1 && b1 != d1 && b1 != c1 )
                    map[sum].push([i, j]);
                } else {
                    map[sum] = [[i, j]];
                }
            }
        }
        
        console.log(map);
        
        for (let key in map) {
          if (map[key].length > 1) {
            let value = map[key];
            
            let firstPair = value[0];
            for (let i = 1; i < value.length; i++) {
              let secondPair = value[i];
              if (secondPair[1] != firstPair[1] && secondPair[0] != firstPair[1]) {
                
                if (!ans.length) {
                  ans = [firstPair[0], firstPair[1], secondPair[0], secondPair[1]];
                } else {
                  if (ans[0] > firstPair[0]){
                    ans = [firstPair[0], firstPair[1], secondPair[0], secondPair[1]];
                  }
                  else if (ans[0] == firstPair[0] && ans[1] > firstPair[1]) {
                    ans = [firstPair[0], firstPair[1], secondPair[0], secondPair[1]];
                  } else if (ans[0] == firstPair[0] && ans[1] == firstPair[1] && ans[2] > secondPair[0]){
                    ans = [firstPair[0], firstPair[1], secondPair[0], secondPair[1]];
                  }
                  else if (ans[0] == firstPair[0] && ans[1] == firstPair[1]
                    && ans[2] == secondPair[0] && ans[3] > secondPair[1]) {
                    ans = [firstPair[0], firstPair[1], secondPair[0], secondPair[1]];
                  }
                  
                }
                break;
              }
            }
          }
        }
        
        console.log(ans);
	}
	
solve([ 1, 1, 1, 1, 1 ]);